<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hangul Typewriter</title>
  </head>
  <style>
    textarea#text {
      width: 100%;
      height: 100px;
    }
    span.fixed {
      word-break: break-all;
      white-space: pre-wrap;
    }
    span.cursor {
      display: inline-block;
      width: 1px;
      height: 1em;
      vertical-align: middle;
      transform: translate(-3px, -2px);
      opacity: 1;
    }
    span.cursor.blink {
      animation: blink 1s step-start infinite;
    }
    @keyframes blink {
      50% {
        opacity: 0;
      }
    }
  </style>
  <body>
    <section id="tools">
      <textarea id="text"></textarea>
      <button class="start">실행</button>
      <button class="reset">초기화</button>
    </section>
    <section id="typewriter">
      <span class="cursor"></span>
    </section>
  </body>
  <script>
    const CHO_TABLE = [
      "ㄱ",
      "ㄲ",
      "ㄴ",
      "ㄷ",
      "ㄸ",
      "ㄹ",
      "ㅁ",
      "ㅂ",
      "ㅃ",
      "ㅅ",
      "ㅆ",
      "ㅇ",
      "ㅈ",
      "ㅉ",
      "ㅊ",
      "ㅋ",
      "ㅌ",
      "ㅍ",
      "ㅎ",
    ];
    const JUNG_TABLE = [
      "ㅏ",
      "ㅐ",
      "ㅑ",
      "ㅒ",
      "ㅓ",
      "ㅔ",
      "ㅕ",
      "ㅖ",
      "ㅗ",
      "ㅘ",
      "ㅙ",
      "ㅚ",
      "ㅛ",
      "ㅜ",
      "ㅝ",
      "ㅞ",
      "ㅟ",
      "ㅠ",
      "ㅡ",
      "ㅢ",
      "ㅣ",
    ];
    const JONG_TABLE = [
      "",
      "ㄱ",
      "ㄲ",
      "ㄳ",
      "ㄴ",
      "ㄵ",
      "ㄶ",
      "ㄷ",
      "ㄹ",
      "ㄺ",
      "ㄻ",
      "ㄼ",
      "ㄽ",
      "ㄾ",
      "ㄿ",
      "ㅀ",
      "ㅁ",
      "ㅂ",
      "ㅄ",
      "ㅅ",
      "ㅆ",
      "ㅇ",
      "ㅈ",
      "ㅊ",
      "ㅋ",
      "ㅌ",
      "ㅍ",
      "ㅎ",
    ];

    // 유니코드 한글 완성형 조합 수는 19 × 21 × 28 = 11,172개로 3차원 배열 [초][중][종]
    // 따라서 초성은 588칸씩, 중성은 28칸씩 점프
    // const CHO_LENGTH = CHO_TABLE.length; // 19
    const JUNG_LENGTH = JUNG_TABLE.length; // 21
    const JONG_LENGTH = JONG_TABLE.length; // 28

    const CHO_STRIDE = JUNG_LENGTH * JONG_LENGTH;
    const JUNG_STRIDE = JONG_LENGTH;

    const UNICODE_HANGUL_FIRST = 0xac00;
    const UNICODE_HANGUL_LAST = 0xd7a3;

    const elCursor = document.querySelector("span.cursor");
    // DOM 요소는 span 2개를 준비하여 하나는 최종 문자 push, 다른 하나는 마지막 문자 변경
    const elSection = document.querySelector("section#typewriter");
    const elFixed = document.createElement("span");
    elFixed.className = "fixed";
    elFixed.textContent = "";
    const elCurrent = document.createElement("span");
    elCurrent.className = "current";
    elCurrent.textContent = "";
    elSection.prepend(elCurrent);
    elSection.prepend(elFixed);

    const cursorColor = window.getComputedStyle(elCurrent).color;
    elCursor.style.backgroundColor = cursorColor;

    // 출력 단계 2차원 배열 생성
    function genCharSteps(string) {
      const result = [];

      // 이모지의 경우 복수의 유니코드 조합
      // 이모지를 지원할 경우...
      // 1) string 순회 시 for 문이나 for of 문을 사용할 경우 깨지기 때문에 Intl.Segmenter 사용 필요
      // 2) result 요소를 배열로만 넣어야 정상 표시됨
      const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" });
      const graphemes = [...segmenter.segment(string)];

      for (let { segment } of graphemes) {
        // 이모지
        if (/\p{Extended_Pictographic}/u.test(segment)) {
          result.push([segment]);
          continue;
        }
        // 일반 문자
        const sCode = segment.charCodeAt(0);
        const steps = getSteps(sCode);
        result.push(steps);
      }

      return result;
    }

    // 일반 문자 배열 생성
    function getSteps(sCode, s) {
      // 한글 완성형 유니코드: 0xAC00 ~ 0xD7A3
      if (sCode >= UNICODE_HANGUL_FIRST && sCode <= UNICODE_HANGUL_LAST) {
        const arr = [];

        // 1. 초성, 중성, 종성 인덱스 생성
        const offset = sCode - UNICODE_HANGUL_FIRST;
        const cho = Math.floor(offset / CHO_STRIDE);
        const jung = Math.floor((offset % CHO_STRIDE) / JUNG_STRIDE);
        const jong = offset % JONG_LENGTH;

        // 2. 표시할 문자 생성
        // 초성만 표시, 유니코드 사용 시 반각으로 표시되므로 별도의 테이블 데이터 사용
        const textFirst = CHO_TABLE[cho];
        // 초성 + 중성
        const codeSecond =
          UNICODE_HANGUL_FIRST + cho * CHO_STRIDE + jung * JUNG_STRIDE;
        const textSecond = String.fromCharCode(codeSecond);
        // 초성 + 종성
        const codeThird = codeSecond + jong;
        const textThird = String.fromCharCode(codeThird);

        // 3. 표시할 문자 저장
        arr.push(textFirst, textSecond);
        // 받침이 있는 경우
        if (codeSecond !== codeThird) {
          arr.push(textThird);
        }
        return arr;
      } else {
        // 기타 영어, 한글 초성, 개행문자 등
        if (sCode === 32) {
          // \u00A0(160): &nbsp;로 개행되지 않음
          // \u200B(8203): 필요한 경우 강제 개행
          // 기본 공백 타이핑 효과 미적용, 개행 이슈 해결
          return ["\u200B\u00A0"];
        }
        return [String.fromCharCode(sCode)];
      }
    }

    let timeoutId = null;
    let stopFlag = false;
    const cursor = {
      start() {
        elCursor.classList.remove("blink");
      },
      pause() {
        elCursor.classList.add("blink");
      },
    };

    async function typeLetters(stepsArray) {
      stopFlag = false;
      cursor.start();

      for (let i = 0; i < stepsArray.length; i++) {
        const steps = stepsArray[i];
        for (let j = 0; j < steps.length; j++) {
          if (stopFlag) return;
          const char = steps[j];

          // 문자가 완성된 경우 고정된 문자열에 추가하고 현재 문자를 비움
          if (j === steps.length - 1) {
            elFixed.textContent += char;
            elCurrent.textContent = "";
          } else {
            elCurrent.textContent = char;
          }

          const [nextChar] = stepsArray[i + 1] ?? "";
          const [prevChar] = stepsArray[i - 1] ?? "";
          const breakChars = ["\n", "\r", "\r\n"];
          const puncChars = [".", "?", "!"];

          const isDelay =
            breakChars.includes(char) ||
            (puncChars.includes(char) && !puncChars.includes(nextChar));

          const ms = isDelay
            ? Math.random() * 400 + 200
            : Math.random() * 100 + 50;

          // 반복문 내 비동기 처리
          await new Promise((resolve) => {
            requestAnimationFrame(() => {
              timeoutId = setTimeout(() => {
                resolve();
              }, ms);
            });
          });
        }
      }
      // 타이핑 완료
      stopTyping();
    }

    function stopTyping() {
      stopFlag = true;
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = null;
      cursor.pause();
    }

    const storage = {
      key: "typewriter",
      default: `타자기 효과를 만들어요. 한글 초성, 중성, 종성을 쪼개봐요.
이모지도 지원해요.🦜 이모지는 일반 문자와 다르니까 조심해요.`,
      get() {
        return localStorage.getItem(this.key);
      },
      set(text) {
        localStorage.setItem(this.key, text);
      },
      remove() {
        localStorage.removeItem(this.key);
      },
    };

    const textareaText = document.querySelector("textarea#text");
    const btnStart = document.querySelector("button.start");
    const btnReset = document.querySelector("button.reset");

    window.addEventListener("DOMContentLoaded", () => {
      let text = "";
      const saved = storage.get();
      if (saved) {
        text = saved;
      } else {
        text = storage.default;
      }
      textareaText.textContent = text;
      const charSteps = genCharSteps(text);
      typeLetters(charSteps);
    });

    btnStart.addEventListener("click", () => {
      stopTyping();
      elCurrent.textContent = "";
      elFixed.textContent = "";

      const text = textareaText.value;
      storage.set(text);
      if (text) {
        const charSteps = genCharSteps(text);
        typeLetters(charSteps);
      }
    });
    btnReset.addEventListener("click", () => {
      stopTyping();
      elCurrent.textContent = "";
      elFixed.textContent = "";

      storage.remove();
      textareaText.value = storage.default;
    });

    // const offset = "안".charCodeAt() - 0xac00;
    // const cho = Math.floor(offset / (21 * 28));
    // const jung = Math.floor((offset % (21 * 28)) / 28);
    // const jong = offset % 28;

    // const code = 0xac00 + cho * 21 * 28 + jung * 28 + jong;
    // const char = String.fromCharCode(code);
    // console.log(char);
  </script>
</html>
