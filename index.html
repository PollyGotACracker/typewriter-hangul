<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hangul Typewriter</title>
  </head>
  <style>
    textarea#text {
      width: 100%;
      height: 100px;
    }
    span.fixed {
      word-break: break-all;
      white-space: pre-wrap;
    }
    span.cursor {
      display: inline-block;
      width: 1px;
      height: 1em;
      vertical-align: middle;
      transform: translate(-3px, -2px);
      opacity: 1;
    }
    span.cursor.blink {
      animation: blink 1s step-start infinite;
    }
    @keyframes blink {
      50% {
        opacity: 0;
      }
    }
  </style>
  <body>
    <section id="tools">
      <textarea id="text"></textarea>
      <button class="start">ì‹¤í–‰</button>
      <button class="reset">ì´ˆê¸°í™”</button>
    </section>
    <section id="typewriter">
      <span class="cursor"></span>
    </section>
  </body>
  <script>
    const CHO_TABLE = [
      "ã„±",
      "ã„²",
      "ã„´",
      "ã„·",
      "ã„¸",
      "ã„¹",
      "ã…",
      "ã…‚",
      "ã…ƒ",
      "ã……",
      "ã…†",
      "ã…‡",
      "ã…ˆ",
      "ã…‰",
      "ã…Š",
      "ã…‹",
      "ã…Œ",
      "ã…",
      "ã…Ž",
    ];
    const JUNG_TABLE = [
      "ã…",
      "ã…",
      "ã…‘",
      "ã…’",
      "ã…“",
      "ã…”",
      "ã…•",
      "ã…–",
      "ã…—",
      "ã…˜",
      "ã…™",
      "ã…š",
      "ã…›",
      "ã…œ",
      "ã…",
      "ã…ž",
      "ã…Ÿ",
      "ã… ",
      "ã…¡",
      "ã…¢",
      "ã…£",
    ];
    const JONG_TABLE = [
      "",
      "ã„±",
      "ã„²",
      "ã„³",
      "ã„´",
      "ã„µ",
      "ã„¶",
      "ã„·",
      "ã„¹",
      "ã„º",
      "ã„»",
      "ã„¼",
      "ã„½",
      "ã„¾",
      "ã„¿",
      "ã…€",
      "ã…",
      "ã…‚",
      "ã…„",
      "ã……",
      "ã…†",
      "ã…‡",
      "ã…ˆ",
      "ã…Š",
      "ã…‹",
      "ã…Œ",
      "ã…",
      "ã…Ž",
    ];

    // ìœ ë‹ˆì½”ë“œ í•œê¸€ ì™„ì„±í˜• ì¡°í•© ìˆ˜ëŠ” 19 Ã— 21 Ã— 28 = 11,172ê°œë¡œ 3ì°¨ì› ë°°ì—´ [ì´ˆ][ì¤‘][ì¢…]
    // ë”°ë¼ì„œ ì´ˆì„±ì€ 588ì¹¸ì”©, ì¤‘ì„±ì€ 28ì¹¸ì”© ì í”„
    // const CHO_LENGTH = CHO_TABLE.length; // 19
    const JUNG_LENGTH = JUNG_TABLE.length; // 21
    const JONG_LENGTH = JONG_TABLE.length; // 28

    const CHO_STRIDE = JUNG_LENGTH * JONG_LENGTH;
    const JUNG_STRIDE = JONG_LENGTH;

    const UNICODE_HANGUL_FIRST = 0xac00;
    const UNICODE_HANGUL_LAST = 0xd7a3;

    const elCursor = document.querySelector("span.cursor");
    // DOM ìš”ì†ŒëŠ” span 2ê°œë¥¼ ì¤€ë¹„í•˜ì—¬ í•˜ë‚˜ëŠ” ìµœì¢… ë¬¸ìž push, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ë§ˆì§€ë§‰ ë¬¸ìž ë³€ê²½
    const elSection = document.querySelector("section#typewriter");
    const elFixed = document.createElement("span");
    elFixed.className = "fixed";
    elFixed.textContent = "";
    const elCurrent = document.createElement("span");
    elCurrent.className = "current";
    elCurrent.textContent = "";
    elSection.prepend(elCurrent);
    elSection.prepend(elFixed);

    const cursorColor = window.getComputedStyle(elCurrent).color;
    elCursor.style.backgroundColor = cursorColor;

    // ì¶œë ¥ ë‹¨ê³„ 2ì°¨ì› ë°°ì—´ ìƒì„±
    function genCharSteps(string) {
      const result = [];

      // ì´ëª¨ì§€ì˜ ê²½ìš° ë³µìˆ˜ì˜ ìœ ë‹ˆì½”ë“œ ì¡°í•©
      // ì´ëª¨ì§€ë¥¼ ì§€ì›í•  ê²½ìš°...
      // 1) string ìˆœíšŒ ì‹œ for ë¬¸ì´ë‚˜ for of ë¬¸ì„ ì‚¬ìš©í•  ê²½ìš° ê¹¨ì§€ê¸° ë•Œë¬¸ì— Intl.Segmenter ì‚¬ìš© í•„ìš”
      // 2) result ìš”ì†Œë¥¼ ë°°ì—´ë¡œë§Œ ë„£ì–´ì•¼ ì •ìƒ í‘œì‹œë¨
      const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" });
      const graphemes = [...segmenter.segment(string)];

      for (let { segment } of graphemes) {
        // ì´ëª¨ì§€
        if (/\p{Extended_Pictographic}/u.test(segment)) {
          result.push([segment]);
          continue;
        }
        // ì¼ë°˜ ë¬¸ìž
        const sCode = segment.charCodeAt(0);
        const steps = getSteps(sCode);
        result.push(steps);
      }

      return result;
    }

    // ì¼ë°˜ ë¬¸ìž ë°°ì—´ ìƒì„±
    function getSteps(sCode, s) {
      // í•œê¸€ ì™„ì„±í˜• ìœ ë‹ˆì½”ë“œ: 0xAC00 ~ 0xD7A3
      if (sCode >= UNICODE_HANGUL_FIRST && sCode <= UNICODE_HANGUL_LAST) {
        const arr = [];

        // 1. ì´ˆì„±, ì¤‘ì„±, ì¢…ì„± ì¸ë±ìŠ¤ ìƒì„±
        const offset = sCode - UNICODE_HANGUL_FIRST;
        const cho = Math.floor(offset / CHO_STRIDE);
        const jung = Math.floor((offset % CHO_STRIDE) / JUNG_STRIDE);
        const jong = offset % JONG_LENGTH;

        // 2. í‘œì‹œí•  ë¬¸ìž ìƒì„±
        // ì´ˆì„±ë§Œ í‘œì‹œ, ìœ ë‹ˆì½”ë“œ ì‚¬ìš© ì‹œ ë°˜ê°ìœ¼ë¡œ í‘œì‹œë˜ë¯€ë¡œ ë³„ë„ì˜ í…Œì´ë¸” ë°ì´í„° ì‚¬ìš©
        const textFirst = CHO_TABLE[cho];
        // ì´ˆì„± + ì¤‘ì„±
        const codeSecond =
          UNICODE_HANGUL_FIRST + cho * CHO_STRIDE + jung * JUNG_STRIDE;
        const textSecond = String.fromCharCode(codeSecond);
        // ì´ˆì„± + ì¢…ì„±
        const codeThird = codeSecond + jong;
        const textThird = String.fromCharCode(codeThird);

        // 3. í‘œì‹œí•  ë¬¸ìž ì €ìž¥
        arr.push(textFirst, textSecond);
        // ë°›ì¹¨ì´ ìžˆëŠ” ê²½ìš°
        if (codeSecond !== codeThird) {
          arr.push(textThird);
        }
        return arr;
      } else {
        // ê¸°íƒ€ ì˜ì–´, í•œê¸€ ì´ˆì„±, ê°œí–‰ë¬¸ìž ë“±
        if (sCode === 32) {
          // \u00A0(160): &nbsp;ë¡œ ê°œí–‰ë˜ì§€ ì•ŠìŒ
          // \u200B(8203): í•„ìš”í•œ ê²½ìš° ê°•ì œ ê°œí–‰
          // ê¸°ë³¸ ê³µë°± íƒ€ì´í•‘ íš¨ê³¼ ë¯¸ì ìš©, ê°œí–‰ ì´ìŠˆ í•´ê²°
          return ["\u200B\u00A0"];
        }
        return [String.fromCharCode(sCode)];
      }
    }

    let timeoutId = null;
    let stopFlag = false;
    const cursor = {
      start() {
        elCursor.classList.remove("blink");
      },
      pause() {
        elCursor.classList.add("blink");
      },
    };

    async function typeLetters(stepsArray) {
      stopFlag = false;
      cursor.start();

      for (let i = 0; i < stepsArray.length; i++) {
        const steps = stepsArray[i];
        for (let j = 0; j < steps.length; j++) {
          if (stopFlag) return;
          const char = steps[j];

          // ë¬¸ìžê°€ ì™„ì„±ëœ ê²½ìš° ê³ ì •ëœ ë¬¸ìžì—´ì— ì¶”ê°€í•˜ê³  í˜„ìž¬ ë¬¸ìžë¥¼ ë¹„ì›€
          if (j === steps.length - 1) {
            elFixed.textContent += char;
            elCurrent.textContent = "";
          } else {
            elCurrent.textContent = char;
          }

          const [nextChar] = stepsArray[i + 1] ?? "";
          const [prevChar] = stepsArray[i - 1] ?? "";
          const breakChars = ["\n", "\r", "\r\n"];
          const puncChars = [".", "?", "!"];

          const isDelay =
            breakChars.includes(char) ||
            (puncChars.includes(char) && !puncChars.includes(nextChar));

          const ms = isDelay
            ? Math.random() * 400 + 200
            : Math.random() * 100 + 50;

          // ë°˜ë³µë¬¸ ë‚´ ë¹„ë™ê¸° ì²˜ë¦¬
          await new Promise((resolve) => {
            requestAnimationFrame(() => {
              timeoutId = setTimeout(() => {
                resolve();
              }, ms);
            });
          });
        }
      }
      // íƒ€ì´í•‘ ì™„ë£Œ
      stopTyping();
    }

    function stopTyping() {
      stopFlag = true;
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = null;
      cursor.pause();
    }

    const storage = {
      key: "typewriter",
      default: `íƒ€ìžê¸° íš¨ê³¼ë¥¼ ë§Œë“¤ì–´ìš”. í•œê¸€ ì´ˆì„±, ì¤‘ì„±, ì¢…ì„±ì„ ìª¼ê°œë´ìš”.
ì´ëª¨ì§€ë„ ì§€ì›í•´ìš”.ðŸ¦œ ì´ëª¨ì§€ëŠ” ì¼ë°˜ ë¬¸ìžì™€ ë‹¤ë¥´ë‹ˆê¹Œ ì¡°ì‹¬í•´ìš”.`,
      get() {
        return localStorage.getItem(this.key);
      },
      set(text) {
        localStorage.setItem(this.key, text);
      },
      remove() {
        localStorage.removeItem(this.key);
      },
    };

    const textareaText = document.querySelector("textarea#text");
    const btnStart = document.querySelector("button.start");
    const btnReset = document.querySelector("button.reset");

    window.addEventListener("DOMContentLoaded", () => {
      let text = "";
      const saved = storage.get();
      if (saved) {
        text = saved;
      } else {
        text = storage.default;
      }
      textareaText.textContent = text;
      const charSteps = genCharSteps(text);
      typeLetters(charSteps);
    });

    btnStart.addEventListener("click", () => {
      stopTyping();
      elCurrent.textContent = "";
      elFixed.textContent = "";

      const text = textareaText.value;
      storage.set(text);
      if (text) {
        const charSteps = genCharSteps(text);
        typeLetters(charSteps);
      }
    });
    btnReset.addEventListener("click", () => {
      stopTyping();
      elCurrent.textContent = "";
      elFixed.textContent = "";

      storage.remove();
      textareaText.value = storage.default;
    });

    // const offset = "ì•ˆ".charCodeAt() - 0xac00;
    // const cho = Math.floor(offset / (21 * 28));
    // const jung = Math.floor((offset % (21 * 28)) / 28);
    // const jong = offset % 28;

    // const code = 0xac00 + cho * 21 * 28 + jung * 28 + jong;
    // const char = String.fromCharCode(code);
    // console.log(char);
  </script>
</html>
